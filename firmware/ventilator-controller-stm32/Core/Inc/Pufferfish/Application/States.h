/*
 * Application.h
 *
 *  Created on: May 26, 2020
 *      Author: Ethan Li
 */

#pragma once

#include "Pufferfish/Protocols/Application/States.h"
#include "Pufferfish/Util/Enums.h"
#include "Pufferfish/Util/TaggedUnion.h"
#include "boost/pfr.hpp"
#include "mcu_pb.h"

// Equality operators
// Since nanopb declares all structs in the global namespace, we also have to declare the operators
// in the global namespace so that the compiler can find them.

// For regular POD structs including structs generated by nanopb, we can use the Boost PFR library's
// equality operator. We can't use C++20's default comparison operator <=> which works on structs,
// because right now we haven't figured out how to migrate to C++20 on the STM32CubeIDE-provided GCC
// toolchain. However, nanopb-generated structs which contain "repeated"s or "oneof"s will need
// custom equality operators to be defined.

template <typename MessageType>
constexpr bool operator==(const MessageType &first, const MessageType &second) {
  return boost::pfr::eq_fields(first, second);
}

template <>
bool operator==<NextLogEvents>(const NextLogEvents &first, const NextLogEvents &second);

template <>
bool operator==<ActiveLogEvents>(const ActiveLogEvents &first, const ActiveLogEvents &second);

namespace Pufferfish::Application {

// Message constants
static const size_t next_log_events_max_elems = 2;
static const size_t active_log_events_max_elems = 32;

// Type tags

// To add a new message type, add it to MessageTypes, MessageTypeValues,
// and Driver::Serial::Backend::message_descriptors in this file.
// Then update StateSegmentUnion in States.tpp. Then add a setter to
// States.cpp using the STATESEGMENT_TAGGED_SETTER macro, add setters and
// getters to the States class as needed, and add switch cases to the
// States::input and States::output methods.
// To make the Backend recognize it as an input, add it to
// Driver::Serial::Backend::InputStates. To make Backend send it as an
// output, add it to Driver::Serial::Backend::state_sync_schedule.
enum class MessageTypes : uint8_t {
  unknown = 0,
  reserved = 1,
  sensor_measurements = 2,
  cycle_measurements = 3,
  parameters = 4,
  parameters_request = 5,
  alarm_limits = 6,
  alarm_limits_request = 7,
  expected_log_event = 8,
  next_log_events = 9,
  active_log_events = 10,
  alarm_mute = 11,
  alarm_mute_request = 12,
  mcu_power_status = 20
};

// MessageTypeValues should include all defined values of MessageTypes
using MessageTypeValues = Util::EnumValues<
    MessageTypes,
    MessageTypes::unknown,
    MessageTypes::sensor_measurements,
    MessageTypes::cycle_measurements,
    MessageTypes::parameters,
    MessageTypes::parameters_request,
    MessageTypes::alarm_limits,
    MessageTypes::alarm_limits_request,
    MessageTypes::expected_log_event,
    MessageTypes::next_log_events,
    MessageTypes::active_log_events,
    MessageTypes::alarm_mute,
    MessageTypes::alarm_mute_request,
    MessageTypes::mcu_power_status>;

// StateSegments

// Since nanopb is running dynamically, we cannot have extensive compile-time type-checking.
// It's not clear how we might use variants to replace this union, since the nanopb functions
// would need access to the underlying memory in the variant, which is not publicly accessible.
// For now the State Segment class is a simple tagged union, though we don't have any compiler
// type-checking with the tags - it's enforced with the templated functions.
union StateSegmentUnion;

using StateSegment = Util::TaggedUnion<StateSegmentUnion, MessageTypes>;

struct StateSegments {
  // Backend States
  SensorMeasurements sensor_measurements;  // noise-filtered
  CycleMeasurements cycle_measurements;
  Parameters parameters;
  ParametersRequest parameters_request;
  AlarmLimits alarm_limits;
  AlarmLimitsRequest alarm_limits_request;
  ExpectedLogEvent expected_log_event;
  NextLogEvents next_log_events;
  ActiveLogEvents active_log_events;
  AlarmMute alarm_mute;
  AlarmMuteRequest alarm_mute_request;
  MCUPowerStatus mcu_power_status;

  // Internal States
  SensorMeasurements sensor_measurements_raw;
  bool backend_connected;
};

// Store

class Store : public Protocols::Application::IndexedStateSender<MessageTypes, StateSegment> {
 public:
  using Status = Protocols::Application::StateOutputStatus;

  Store() = default;

  // Backend States
  SensorMeasurements &sensor_measurements_filtered();
  CycleMeasurements &cycle_measurements();
  Parameters &parameters();
  [[nodiscard]] bool has_parameters_request() const;
  [[nodiscard]] const ParametersRequest &parameters_request() const;
  AlarmLimits &alarm_limits();
  [[nodiscard]] bool has_alarm_limits_request() const;
  [[nodiscard]] const AlarmLimitsRequest &alarm_limits_request() const;
  [[nodiscard]] const ExpectedLogEvent &expected_log_event() const;
  NextLogEvents &next_log_events();
  ActiveLogEvents &active_log_events();
  AlarmMute &alarm_mute();
  AlarmMuteRequest &alarm_mute_request();
  MCUPowerStatus &mcu_power_status();

  // Internal States
  SensorMeasurements &sensor_measurements_raw();
  bool &backend_connected();

  Status input(const StateSegment &input, bool default_initialization = false);
  Status output(MessageTypes type, StateSegment &output) const override;

 private:
  StateSegments state_segments_{};
  bool has_parameters_request_ = false;
  bool has_alarm_limits_request_ = false;
};

}  // namespace Pufferfish::Application

#include "States.tpp"
