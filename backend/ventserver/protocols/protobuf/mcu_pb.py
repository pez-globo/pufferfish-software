# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: mcu_pb.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


class VentilationMode(betterproto.Enum):
    hfnc = 0
    pc_ac = 1
    vc_ac = 2
    niv_pc = 3
    niv_ps = 4
    psv = 5
    prvc = 6


class LogEventCode(betterproto.Enum):
    # Patient alarms
    fio2_too_low = 0
    fio2_too_high = 1
    flow_too_low = 2
    flow_too_high = 3
    spo2_too_low = 4
    spo2_too_high = 5
    hr_too_low = 6
    hr_too_high = 7
    # Control settings
    ventilation_operation_changed = 64
    ventilation_mode_changed = 65
    fio2_setting_changed = 66
    flow_setting_changed = 67
    # Alarm limits settings
    fio2_alarm_limits_changed = 80
    flow_alarm_limits_changed = 81
    spo2_alarm_limits_changed = 82
    hr_alarm_limits_changed = 83
    # System settings & alarms
    screen_locked = 129
    mcu_backend_connection_down = 130
    backend_mcu_connection_down = 131
    backend_frontend_connection_down = 132
    # TODO: if the backend can't send data to the frontend but the frontend can
    # send data to the backend, we should make the backend generate a
    # frontend_backend_down log event so that there's some record in the event
    # log of a connection problem. We can achieve this using a
    # FrontendConnections message type which the frontend sends to the backend.
    frontend_backend_connection_down = 133
    mcu_backend_connection_up = 134
    # TODO: if the mcu can't send data to the backend but the backend can send
    # data to the mcu, we should make the backend generate a backend_mcu_up log
    # event once the mcu becomes able to send data again so that the event log
    # has a connection_up event to match the connection_down event.
    backend_mcu_connection_up = 135
    backend_frontend_connection_up = 136
    # TODO: if the backend can't send data to the frontend but the frontend can
    # send data to the backend, we should make the backend generate a
    # frontend_backend_up log event once the frontend detects that the backend is
    # able to send data again, so that the event log has a connection_up event to
    # match the connection_down event. We can achieve this using a
    # FrontendConnections message type which the frontend sends to the backend.
    frontend_backend_connection_up = 137
    battery_low = 138
    battery_critical = 139
    charger_disconnected = 140
    mcu_started = 141
    backend_started = 142
    mcu_shutdown = 143
    backend_shutdown = 144
    sysclock_changed = 145
    # Alarm muting/unmuting
    alarms_muted_user_software = 146
    alarms_muted_user_hardware = 147
    alarms_muted_unknown = 148
    alarms_unmuted_user_software = 149
    alarms_unmuted_user_hardware = 150
    alarms_unmuted_initialization = 151
    alarms_unmuted_timeout = 152
    alarms_unmuted_mcu_backend_loss = 153
    alarms_unmuted_backend_mcu_loss = 154
    alarms_unmuted_backend_frontend_loss = 155
    alarms_unmuted_frontend_backend_loss = 156
    alarms_unmuted_unknown = 157
    # Sensor loss
    sfm3019_air_disconnected = 160
    sfm3019_o2_disconnected = 161
    fdo2_disconnected = 162
    nonin_disconnected = 163
    nonin_finger_sensor_disconnected = 164
    nonin_sensor_alarm = 165
    nonin_out_of_track_measurements = 166


class LogEventType(betterproto.Enum):
    patient = 0
    control = 1
    alarm_limits = 2
    system = 3


class AlarmMuteSource(betterproto.Enum):
    initialization = 0
    user_software = 1
    user_hardware = 2
    timeout = 3
    mcu_backend_loss = 4
    backend_mcu_loss = 5
    backend_frontend_loss = 6
    frontend_backend_loss = 7


@dataclass
class SensorMeasurements(betterproto.Message):
    time: int = betterproto.uint64_field(1)
    cycle: int = betterproto.uint32_field(2)
    fio2: float = betterproto.float_field(3)
    flow: float = betterproto.float_field(4)
    spo2: float = betterproto.float_field(5)
    hr: float = betterproto.float_field(6)
    paw: float = betterproto.float_field(7)
    volume: float = betterproto.float_field(8)


@dataclass
class CycleMeasurements(betterproto.Message):
    time: int = betterproto.uint64_field(1)
    vt: float = betterproto.float_field(2)
    rr: float = betterproto.float_field(3)
    peep: float = betterproto.float_field(4)
    pip: float = betterproto.float_field(5)
    ip: float = betterproto.float_field(6)
    ve: float = betterproto.float_field(7)


@dataclass
class Parameters(betterproto.Message):
    time: int = betterproto.uint64_field(1)
    ventilating: bool = betterproto.bool_field(2)
    mode: "VentilationMode" = betterproto.enum_field(3)
    fio2: float = betterproto.float_field(4)
    flow: float = betterproto.float_field(5)
    pip: float = betterproto.float_field(6)
    peep: float = betterproto.float_field(7)
    vt: float = betterproto.float_field(8)
    rr: float = betterproto.float_field(9)
    ie: float = betterproto.float_field(10)


@dataclass
class ParametersRequest(betterproto.Message):
    time: int = betterproto.uint64_field(1)
    ventilating: bool = betterproto.bool_field(2)
    mode: "VentilationMode" = betterproto.enum_field(3)
    fio2: float = betterproto.float_field(4)
    flow: float = betterproto.float_field(5)
    pip: float = betterproto.float_field(6)
    peep: float = betterproto.float_field(7)
    vt: float = betterproto.float_field(8)
    rr: float = betterproto.float_field(9)
    ie: float = betterproto.float_field(10)


@dataclass
class Range(betterproto.Message):
    lower: int = betterproto.int32_field(1)
    upper: int = betterproto.int32_field(2)


@dataclass
class AlarmLimits(betterproto.Message):
    """
    TODO: AlarmLimits has a max size above 256 bytes, so we need to increase
    the communication protocol's chunks from a max length of 256 bytes to
    something more like 512 bytes!
    """

    time: int = betterproto.uint64_field(1)
    fio2: "Range" = betterproto.message_field(2)
    flow: "Range" = betterproto.message_field(3)
    spo2: "Range" = betterproto.message_field(4)
    hr: "Range" = betterproto.message_field(5)
    rr: "Range" = betterproto.message_field(6)
    pip: "Range" = betterproto.message_field(7)
    peep: "Range" = betterproto.message_field(8)
    ip_above_peep: "Range" = betterproto.message_field(9)
    insp_time: "Range" = betterproto.message_field(10)
    paw: "Range" = betterproto.message_field(11)
    mve: "Range" = betterproto.message_field(12)
    tv: "Range" = betterproto.message_field(13)
    etco2: "Range" = betterproto.message_field(14)
    apnea: "Range" = betterproto.message_field(15)


@dataclass
class AlarmLimitsRequest(betterproto.Message):
    """
    TODO: AlarmLimitsRequest has a max size above 256 bytes, so we need to
    increase the communication protocol's chunks from a max length of 256 bytes
    to something more like 512 bytes!
    """

    time: int = betterproto.uint64_field(1)
    fio2: "Range" = betterproto.message_field(2)
    flow: "Range" = betterproto.message_field(3)
    spo2: "Range" = betterproto.message_field(4)
    hr: "Range" = betterproto.message_field(5)
    rr: "Range" = betterproto.message_field(6)
    pip: "Range" = betterproto.message_field(7)
    peep: "Range" = betterproto.message_field(8)
    ip_above_peep: "Range" = betterproto.message_field(9)
    insp_time: "Range" = betterproto.message_field(10)
    paw: "Range" = betterproto.message_field(11)
    mve: "Range" = betterproto.message_field(12)
    tv: "Range" = betterproto.message_field(13)
    etco2: "Range" = betterproto.message_field(14)
    apnea: "Range" = betterproto.message_field(15)


@dataclass
class LogEvent(betterproto.Message):
    id: int = betterproto.uint32_field(1)
    time: int = betterproto.uint64_field(2)
    code: "LogEventCode" = betterproto.enum_field(3)
    type: "LogEventType" = betterproto.enum_field(4)
    alarm_limits: "Range" = betterproto.message_field(5)
    # TODO: rename these to old/new_double
    old_float: float = betterproto.double_field(6)
    new_float: float = betterproto.double_field(7)
    old_uint32: int = betterproto.uint32_field(8)
    new_uint32: int = betterproto.uint32_field(9)
    old_bool: bool = betterproto.bool_field(10)
    new_bool: bool = betterproto.bool_field(11)
    old_range: "Range" = betterproto.message_field(12)
    new_range: "Range" = betterproto.message_field(13)
    old_mode: "VentilationMode" = betterproto.enum_field(14)
    new_mode: "VentilationMode" = betterproto.enum_field(15)


@dataclass
class ExpectedLogEvent(betterproto.Message):
    id: int = betterproto.uint32_field(1)
    # session_id is checked by the NextLogEvents sender if the sender's log is
    # ephemeral; the sender will ignore any ExpectedLogEvent whose session_id
    # doesn't match the sender's session_id, which is announced in NextLogEvents.
    session_id: int = betterproto.uint32_field(2)


@dataclass
class NextLogEvents(betterproto.Message):
    """
    Note: NextLogEvents has a custom equality operator in the firmware which
    must be updated if you add/remove/modify the fields of the protobuf
    definition! TODO: NextLogEvents has a max size above 256 bytes, so we need
    to increase the communication protocol's chunks from a max length of 256
    bytes to something more like 512 bytes!
    """

    next_expected: int = betterproto.uint32_field(1)
    total: int = betterproto.uint32_field(2)
    remaining: int = betterproto.uint32_field(3)
    session_id: int = betterproto.uint32_field(4)
    elements: List["LogEvent"] = betterproto.message_field(5)


@dataclass
class ActiveLogEvents(betterproto.Message):
    """
    Note: NextLogEvents has a custom equality operator in the firmware which
    must be updated if you add/remove/modify the fields of the protobuf
    definition!
    """

    id: List[int] = betterproto.uint32_field(1)


@dataclass
class AlarmMute(betterproto.Message):
    active: bool = betterproto.bool_field(1)
    # seq_num is a logical clock and advances in the firmware after each local
    # action in the firmware (such as a button-press) or the servicing of each
    # external request.
    seq_num: int = betterproto.uint32_field(2)
    source: "AlarmMuteSource" = betterproto.enum_field(3)
    remaining: int = betterproto.uint64_field(4)


@dataclass
class AlarmMuteRequest(betterproto.Message):
    active: bool = betterproto.bool_field(1)
    # seq_num is a logical clock which also acts as an idempotency key for
    # requests: the firmware only services an AlarmMuteRequest if the request's
    # seq_num is one greater than the seq_num in the firmware's copy of
    # AlarmMute.
    seq_num: int = betterproto.uint32_field(2)
    source: "AlarmMuteSource" = betterproto.enum_field(3)


@dataclass
class MCUPowerStatus(betterproto.Message):
    power_left: float = betterproto.float_field(1)
    charging: bool = betterproto.bool_field(2)


@dataclass
class BackendConnections(betterproto.Message):
    has_mcu: bool = betterproto.bool_field(1)
    has_frontend: bool = betterproto.bool_field(2)


@dataclass
class ScreenStatus(betterproto.Message):
    lock: bool = betterproto.bool_field(1)


@dataclass
class Ping(betterproto.Message):
    time: int = betterproto.uint64_field(1)
    id: int = betterproto.uint32_field(2)


@dataclass
class Announcement(betterproto.Message):
    time: int = betterproto.uint64_field(1)
    announcement: bytes = betterproto.bytes_field(2)
