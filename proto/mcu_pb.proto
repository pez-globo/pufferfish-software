syntax = "proto3";

message Range {
  int32 lower = 1;
  int32 upper = 2;
}

message AlarmLimits {
  uint64 time = 1;
  Range fio2 = 2;
  Range flow = 3;
  Range spo2 = 4;
  Range hr = 5;
  Range rr = 6;
  Range pip = 7;
  Range peep = 8;
  Range ip_above_peep = 9;
  Range insp_time = 10;
  Range paw = 11;
  Range mve = 12;
  Range tv = 13;
  Range etco2 = 14;
  Range apnea = 15;
}

message AlarmLimitsRequest {
  uint64 time = 1;
  Range fio2 = 2;
  Range flow = 3;
  Range spo2 = 4;
  Range hr = 5;
  Range rr = 6;
  Range pip = 7;
  Range peep = 8;
  Range ip_above_peep = 9;
  Range insp_time = 10;
  Range paw = 11;
  Range mve = 12;
  Range tv = 13;
  Range etco2 = 14;
  Range apnea = 15;
}

message SensorMeasurements {
  uint64 time = 1;
  uint32 cycle = 2;
  float fio2 = 3;
  float flow = 4;
  float spo2 = 5;
  float hr = 6;
  float paw = 7;
  float volume = 8;
}

message CycleMeasurements {
  uint64 time = 1;
  float vt = 2;
  float rr = 3;
  float peep = 4;
  float pip = 5;
  float ip = 6;
  float ve = 7;
}

enum VentilationMode {
  hfnc = 0;
  pc_ac = 1;
  vc_ac = 2;
  niv_pc = 3;
  niv_ps = 4;
  psv = 5;
  prvc = 6;
}

message Parameters {
  uint64 time = 1;
  bool ventilating = 2;
  VentilationMode mode = 3;
  float fio2 = 4;
  float flow = 5;
  float pip = 6;
  float peep = 7;
  float vt = 8;
  float rr = 9;
  float ie = 10;
}

message ParametersRequest {
  uint64 time = 1;
  bool ventilating = 2;
  VentilationMode mode = 3;
  float fio2 = 4;
  float flow = 5;
  float pip = 6;
  float peep = 7;
  float vt = 8;
  float rr = 9;
  float ie = 10;
}

// Testing messages

message Ping {
  uint64 time = 1;
  uint32 id = 2;
}

message Announcement {
  uint64 time = 1;
  bytes announcement = 2;
}

// Log Events

enum LogEventCode {
  // Patient alarms
  fio2_too_low = 0;
  fio2_too_high = 1;
  flow_too_low = 2;
  flow_too_high = 3;
  spo2_too_low = 4;
  spo2_too_high = 5;
  hr_too_low = 6;
  hr_too_high = 7;
  // Control settings
  ventilation_operation_changed = 64;
  ventilation_mode_changed = 65;
  fio2_setting_changed = 66;
  flow_setting_changed = 67;
  // Alarm limits settings
  fio2_alarm_limits_changed = 80;
  flow_alarm_limits_changed = 81;
  spo2_alarm_limits_changed = 82;
  hr_alarm_limits_changed = 83;
  // System settings & alarms
  screen_locked = 129;
  mcu_backend_connection_down = 130;  // mcu lost backend
  backend_mcu_connection_down = 131;  // backend lost mcu
  backend_frontend_connection_down = 132;  // backend lost frontend
  frontend_backend_connection_down = 133;  // frontend lost backend
  mcu_backend_connection_up = 134;  // mcu detected backend
  // The following code isn't actually used, but we reserve space for it.
  // We don't use it because if the backend received an mcu_backend_connection_up
  // event from the MCU, then we know that the backend received a connection from
  // the MCU. We only care for technical troubleshooting (of the UART wires) about
  // the case where the backend receives a connection from the MCU but the MCU
  // hasn't received a connection from the backend; it would be good to log it,
  // but we don't need to show it in the frontend, and right now the frontend has
  // no way to filter out events from its display.
  // backend_mcu_connection_up = 135;  // backend detected mcu
  backend_frontend_connection_up = 136;  // backend detected frontend
  // The following code isn't actually used, but we reserve space for it.
  // We don't use it because the frontend can't generate LogEvents with IDs.
  // frontend_backend_connection_up = 137;
  battery_low = 138;
  battery_critical = 139;
  charger_disconnected = 140;
  mcu_started = 141;
  backend_started = 142;
  mcu_shutdown = 143;
  backend_shutdown = 144;
  // Alarm muting/unmuting
  alarms_muted_user_software = 145;
  alarms_muted_user_hardware = 146;
  alarms_muted_unknown = 147;  // Indicates a software bug; should never occur
  alarms_unmuted_user_software = 148;
  alarms_unmuted_user_hardware = 149;
  alarms_unmuted_initialization = 150;
  alarms_unmuted_timeout = 151;
  alarms_unmuted_mcu_backend_loss = 152;
  alarms_unmuted_backend_mcu_loss = 153;
  alarms_unmuted_backend_frontend_loss = 154;
  alarms_unmuted_frontend_backend_loss = 155;
  alarms_unmuted_unknown = 156;  // Indicates a software bug; should never occur
  // Sensor loss
  sfm3019_air_disconnected = 160;
  sfm3019_o2_disconnected = 161;
  fdo2_disconnected = 162;
}

enum LogEventType {
  patient = 0;
  control = 1;
  alarm_limits = 2;
  system = 3;
}

message LogEvent {
  uint32 id = 1;
  uint64 time = 2;
  LogEventCode code = 3;
  LogEventType type = 4;
  Range alarm_limits = 5;
  float old_float = 6;
  float new_float = 7;
  uint32 old_uint32 = 8;
  uint32 new_uint32 = 9;
  bool old_bool = 10;
  bool new_bool = 11;
  Range old_range = 12;
  Range new_range = 13;
  VentilationMode old_mode = 14;
  VentilationMode new_mode = 15;
}

message ExpectedLogEvent {
  uint32 id = 1;
  // session_id is checked by the NextLogEvents sender if the sender's log is
  // ephemeral; the sender will ignore any ExpectedLogEvent whose session_id
  // doesn't match the sender's session_id, which is announced in NextLogEvents.
  uint32 session_id = 2;  // used when the sender's log is ephemeral
}

// Note: NextLogEvents has a custom equality operator in the firmware which must
// be updated if you add/remove/modify the fields of the protobuf definition!
message NextLogEvents {
  uint32 next_expected = 1;
  uint32 total = 2;
  uint32 remaining = 3;
  uint32 session_id = 4;  // used when the sender's log is ephemeral
  repeated LogEvent elements = 5;
}

// Note: NextLogEvents has a custom equality operator in the firmware which must
// be updated if you add/remove/modify the fields of the protobuf definition!
message ActiveLogEvents {
  repeated uint32 id = 1;
}

// MCU power

message MCUPowerStatus {
  float power_left = 1;
  bool charging = 2;
}

// Hardware Buttons

message ScreenStatus {
  bool lock = 1;
}

enum AlarmMuteSource {
  initialization = 0;  // Alarm muting was set on initialization
  user_software = 1;  // User took a software action to change alarm muting
  user_hardware = 2;  // User took a hardware action to change alarm muting
  timeout = 3;  // Alarm mute automatically timed out
  mcu_backend_loss = 4; // Alarm mute was cancelled by mcu due to connection loss
  backend_mcu_loss = 5; // Alarm mute was cancelled by backend due to connection loss
  backend_frontend_loss = 6; // Alarm mute was cancelled by backend due to connection loss
  frontend_backend_loss = 7; // Alarm mute was cancelled by frontend due to connection loss
}

message AlarmMute {
  bool active = 1;
  // seq_num is a logical clock and advances in the firmware after each local action
  // in the firmware (such as a button-press) or the servicing of each external request.
  uint32 seq_num = 2;
  AlarmMuteSource source = 3;
  uint64 remaining = 4;
}

message AlarmMuteRequest {
  bool active = 1;
  // seq_num is a logical clock which also acts as an idempotency key for requests:
  // the firmware only services an AlarmMuteRequest if the request's seq_num is one
  // greater than the seq_num in the firmware's copy of AlarmMute.
  uint32 seq_num = 2;
  AlarmMuteSource source = 3;
}
